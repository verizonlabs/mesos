diff --git a/build_detect_platform b/build_detect_platform
index b71bf02..864e5fb 100755
--- a/build_detect_platform
+++ b/build_detect_platform
@@ -128,24 +128,8 @@ EOF
         COMMON_FLAGS="$COMMON_FLAGS -DLEVELDB_PLATFORM_POSIX"
     fi

-    # Test whether Snappy library is installed
-    # http://code.google.com/p/snappy/
-    $CXX $CFLAGS -x c++ - -o /dev/null 2>/dev/null  <<EOF
-      #include <snappy.h>
-      int main() {}
-EOF
-    if [ "$?" = 0 ]; then
-        COMMON_FLAGS="$COMMON_FLAGS -DSNAPPY"
-        PLATFORM_LDFLAGS="$PLATFORM_LDFLAGS -lsnappy"
-    fi
+# Removed tests for TCMALLOC and SNAPPY to prevent additional dependencies.

-    # Test whether tcmalloc is available
-    $CXX $CFLAGS -x c++ - -o /dev/null -ltcmalloc 2>/dev/null  <<EOF
-      int main() {}
-EOF
-    if [ "$?" = 0 ]; then
-        PLATFORM_LDFLAGS="$PLATFORM_LDFLAGS -ltcmalloc"
-    fi
 fi

 PLATFORM_CCFLAGS="$PLATFORM_CCFLAGS $COMMON_FLAGS"
diff --git a/port/atomic_pointer.h b/port/atomic_pointer.h
index 35ae550..b4769b3 100644
--- a/port/atomic_pointer.h
+++ b/port/atomic_pointer.h
@@ -36,6 +36,8 @@
 #define ARCH_CPU_X86_FAMILY 1
 #elif defined(__ARMEL__)
 #define ARCH_CPU_ARM_FAMILY 1
+#elif defined(__ppc__) || defined(__powerpc__) || defined(__powerpc64__)
+#define ARCH_CPU_PPC_FAMILY 1
 #endif

 namespace leveldb {
@@ -83,6 +85,13 @@ inline void MemoryBarrier() {
 }
 #define LEVELDB_HAVE_MEMORY_BARRIER

+// PPC
+#elif defined(ARCH_CPU_PPC_FAMILY) && defined(__GNUC__)
+inline void MemoryBarrier() {
+  asm volatile("lwsync" : : : "memory");
+}
+#define LEVELDB_HAVE_MEMORY_BARRIER
+
 #endif

 // AtomicPointer built using platform-specific MemoryBarrier()
 diff --git a/port/atomic_pointer.h b/port/atomic_pointer.h
 index b4769b3..1c4c7aa 100644
 --- a/port/atomic_pointer.h
 +++ b/port/atomic_pointer.h
 @@ -5,14 +5,13 @@
  // AtomicPointer provides storage for a lock-free pointer.
  // Platform-dependent implementation of AtomicPointer:
  // - If the platform provides a cheap barrier, we use it with raw pointers
 -// - If cstdatomic is present (on newer versions of gcc, it is), we use
 -//   a cstdatomic-based AtomicPointer.  However we prefer the memory
 +// - If <atomic> is present (on newer versions of gcc, it is), we use
 +//   a <atomic>-based AtomicPointer.  However we prefer the memory
  //   barrier based version, because at least on a gcc 4.4 32-bit build
 -//   on linux, we have encountered a buggy <cstdatomic>
 -//   implementation.  Also, some <cstdatomic> implementations are much
 -//   slower than a memory-barrier based implementation (~16ns for
 -//   <cstdatomic> based acquire-load vs. ~1ns for a barrier based
 -//   acquire-load).
 +//   on linux, we have encountered a buggy <atomic> implementation.
 +//   Also, some <atomic> implementations are much slower than a memory-barrier
 +//   based implementation (~16ns for <atomic> based acquire-load vs. ~1ns for
 +//   a barrier based acquire-load).
  // This code is based on atomicops-internals-* in Google's perftools:
  // http://code.google.com/p/google-perftools/source/browse/#svn%2Ftrunk%2Fsrc%2Fbase

 @@ -20,8 +19,8 @@
  #define PORT_ATOMIC_POINTER_H_

  #include <stdint.h>
 -#ifdef LEVELDB_CSTDATOMIC_PRESENT
 -#include <cstdatomic>
 +#ifdef LEVELDB_ATOMIC_PRESENT
 +#include <atomic>
  #endif
  #ifdef OS_WIN
  #include <windows.h>
 @@ -36,8 +35,12 @@
  #define ARCH_CPU_X86_FAMILY 1
  #elif defined(__ARMEL__)
  #define ARCH_CPU_ARM_FAMILY 1
 +#elif defined(__aarch64__)
 +#define ARCH_CPU_ARM64_FAMILY 1
  #elif defined(__ppc__) || defined(__powerpc__) || defined(__powerpc64__)
  #define ARCH_CPU_PPC_FAMILY 1
 +#elif defined(__mips__)
 +#define ARCH_CPU_MIPS_FAMILY 1
  #endif

  namespace leveldb {
 @@ -50,6 +53,13 @@ namespace port {
  // http://msdn.microsoft.com/en-us/library/ms684208(v=vs.85).aspx
  #define LEVELDB_HAVE_MEMORY_BARRIER

 +// Mac OS
 +#elif defined(OS_MACOSX)
 +inline void MemoryBarrier() {
 +  OSMemoryBarrier();
 +}
 +#define LEVELDB_HAVE_MEMORY_BARRIER
 +
  // Gcc on x86
  #elif defined(ARCH_CPU_X86_FAMILY) && defined(__GNUC__)
  inline void MemoryBarrier() {
 @@ -68,27 +78,44 @@ inline void MemoryBarrier() {
  }
  #define LEVELDB_HAVE_MEMORY_BARRIER

 -// Mac OS
 -#elif defined(OS_MACOSX)
 +// ARM Linux
 +#elif defined(ARCH_CPU_ARM_FAMILY) && defined(__linux__)
 +typedef void (*LinuxKernelMemoryBarrierFunc)(void);
 +// The Linux ARM kernel provides a highly optimized device-specific memory
 +// barrier function at a fixed memory address that is mapped in every
 +// user-level process.
 +//
 +// This beats using CPU-specific instructions which are, on single-core
 +// devices, un-necessary and very costly (e.g. ARMv7-A "dmb" takes more
 +// than 180ns on a Cortex-A8 like the one on a Nexus One). Benchmarking
 +// shows that the extra function call cost is completely negligible on
 +// multi-core devices.
 +//
  inline void MemoryBarrier() {
 -  OSMemoryBarrier();
 +  (*(LinuxKernelMemoryBarrierFunc)0xffff0fa0)();
  }
  #define LEVELDB_HAVE_MEMORY_BARRIER

 -// ARM
 -#elif defined(ARCH_CPU_ARM_FAMILY)
 -typedef void (*LinuxKernelMemoryBarrierFunc)(void);
 -LinuxKernelMemoryBarrierFunc pLinuxKernelMemoryBarrier __attribute__((weak)) =
 -    (LinuxKernelMemoryBarrierFunc) 0xffff0fa0;
 +// ARM64
 +#elif defined(ARCH_CPU_ARM64_FAMILY)
  inline void MemoryBarrier() {
 -  pLinuxKernelMemoryBarrier();
 +  asm volatile("dmb sy" : : : "memory");
  }
  #define LEVELDB_HAVE_MEMORY_BARRIER

  // PPC
  #elif defined(ARCH_CPU_PPC_FAMILY) && defined(__GNUC__)
  inline void MemoryBarrier() {
 -  asm volatile("lwsync" : : : "memory");
 +  // TODO for some powerpc expert: is there a cheaper suitable variant?
 +  // Perhaps by having separate barriers for acquire and release ops.
 +  asm volatile("sync" : : : "memory");
 +}
 +#define LEVELDB_HAVE_MEMORY_BARRIER
 +
 +// MIPS
 +#elif defined(ARCH_CPU_MIPS_FAMILY) && defined(__GNUC__)
 +inline void MemoryBarrier() {
 +  __asm__ __volatile__("sync" : : : "memory");
  }
  #define LEVELDB_HAVE_MEMORY_BARRIER

 @@ -116,7 +143,7 @@ class AtomicPointer {
  };

  // AtomicPointer based on <cstdatomic>
 -#elif defined(LEVELDB_CSTDATOMIC_PRESENT)
 +#elif defined(LEVELDB_ATOMIC_PRESENT)
  class AtomicPointer {
   private:
    std::atomic<void*> rep_;
 @@ -137,7 +164,67 @@ class AtomicPointer {
    }
  };

 -// We have neither MemoryBarrier(), nor <cstdatomic>
 +// Atomic pointer based on sparc memory barriers
 +#elif defined(__sparcv9) && defined(__GNUC__)
 +class AtomicPointer {
 + private:
 +  void* rep_;
 + public:
 +  AtomicPointer() { }
 +  explicit AtomicPointer(void* v) : rep_(v) { }
 +  inline void* Acquire_Load() const {
 +    void* val;
 +    __asm__ __volatile__ (
 +        "ldx [%[rep_]], %[val] \n\t"
 +         "membar #LoadLoad|#LoadStore \n\t"
 +        : [val] "=r" (val)
 +        : [rep_] "r" (&rep_)
 +        : "memory");
 +    return val;
 +  }
 +  inline void Release_Store(void* v) {
 +    __asm__ __volatile__ (
 +        "membar #LoadStore|#StoreStore \n\t"
 +        "stx %[v], [%[rep_]] \n\t"
 +        :
 +        : [rep_] "r" (&rep_), [v] "r" (v)
 +        : "memory");
 +  }
 +  inline void* NoBarrier_Load() const { return rep_; }
 +  inline void NoBarrier_Store(void* v) { rep_ = v; }
 +};
 +
 +// Atomic pointer based on ia64 acq/rel
 +#elif defined(__ia64) && defined(__GNUC__)
 +class AtomicPointer {
 + private:
 +  void* rep_;
 + public:
 +  AtomicPointer() { }
 +  explicit AtomicPointer(void* v) : rep_(v) { }
 +  inline void* Acquire_Load() const {
 +    void* val    ;
 +    __asm__ __volatile__ (
 +        "ld8.acq %[val] = [%[rep_]] \n\t"
 +        : [val] "=r" (val)
 +        : [rep_] "r" (&rep_)
 +        : "memory"
 +        );
 +    return val;
 +  }
 +  inline void Release_Store(void* v) {
 +    __asm__ __volatile__ (
 +        "st8.rel [%[rep_]] = %[v]  \n\t"
 +        :
 +        : [rep_] "r" (&rep_), [v] "r" (v)
 +        : "memory"
 +        );
 +  }
 +  inline void* NoBarrier_Load() const { return rep_; }
 +  inline void NoBarrier_Store(void* v) { rep_ = v; }
 +};
 +
 +// We have neither MemoryBarrier(), nor <atomic>
  #else
  #error Please implement AtomicPointer for this platform.

 @@ -146,6 +233,8 @@ class AtomicPointer {
  #undef LEVELDB_HAVE_MEMORY_BARRIER
  #undef ARCH_CPU_X86_FAMILY
  #undef ARCH_CPU_ARM_FAMILY
 +#undef ARCH_CPU_ARM64_FAMILY
 +#undef ARCH_CPU_PPC_FAMILY

  }  // namespace port
  }  // namespace leveldb
